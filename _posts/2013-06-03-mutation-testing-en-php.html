---
layout: post
title: Mutation Testing en PHP
categories:
- Non classé
tags: []
status: draft
type: post
published: false
meta:
  _syntaxhighlighter_encoded: '1'
  _edit_last: '1'
  image: ''
  seo_follow: 'false'
  seo_noindex: 'false'
---
Mutation Testing en PHP

Aujourd'hui, dans l'écosystème PHP, on ne se pose enfin plus la question de savoir ce qu'est un test unitaire. Les tests unitaires sont devenus une pratique courante, et il existe des frameworks de tests matures, comme PHPUnit ou atoum.

L'engouement pour la qualité logicielle a poussé la communauté à progresser et à proposer de nouvelles pratiques, de nouveaux outils... Cependant, il reste encore exceptionnel (je n'ai jamais entendu parler de projet qui le faisait) de contrôler la qualité des tests unitaires produits.

Attention, je ne parle pas d'indicateurs de couverture de code. Non, car une couverture de code à 100 % est contre-productive, impossible et surtout totalement fausse. Et voici pourquoi 

<h2>Couverture de nœuds et couverture de chemins</h2>
Les outils de couverture actuelle ont un défaut majeur, inhérent à leur fonctionnement : ils indiquent uniquement si des portions de code ont été exécutées lors des tests unitaires. 

Or, prenons un exemple simple :

{% highlight php %}
<?php
class Foo {
    public function bar($x, $y) {
        if($x == 1) {
            echo 'A';
        } else {
            echo 'B';
        }
        
        if($y == 1) {
            echo 'C';
        } else {
            echo 'D';
        }
    }
}
{% endhighlight %}

et le test unitaire suivant :

{% highlight php %}
<?php
require_once __DIR__.'/Foo.php';
class FooTest extends PHPUnit_Framework_TestCase
{
    public function testFoo1()
    {
        $foo = new Foo;
        $foo-&gt;bar(1, 2);
        $foo-&gt;bar(2, 1);
    }
}
{% endhighlight %}

Le premier appel de foo() affiche 'AD', le second affiche 'BC'. Je suis donc passé partout dans mon code source, la couverture de code de ma suite de test est de 100 % :



Super ! 100 % ! J'ai couvert tout mon code ! En plus c'est vert, donc c'est que tout va bien.

Et bien non… ou plutôt, je suis passé à chaque nœud de mon code source, mais je n'ai pas couvert tous les chemins possibles de code. Car avec ces deux if(), le code peut faire :
<ul>
<li>A, C</li>
<li>A, D</li>
<li>B, C</li>
<li>B, D</li>
</ul>

Quatre chemins possibles donc, alors que la couverture de code est de 100 % en à peine deux tests. La couverture de code est donc un indicateur assez peu fiable, puisqu'elle nous trompe allègrement : dans mon exemple, très simple, je n'ai en réalité couvert que 50 % des chemins possibles ; et encore, uniquement pour cette portion de code. Et le code est très simple : imaginez un switch() avec des if() imbriqués, vous verrez qu'en réalité la différence entre la réalité et la couverture de code indiquée est exponentielle.

<h2>Pire : les test unitaires ne testent rien</h2>

Attendez, j'ai donc ici une couverture de code de 100 %, mais, en réalité, mes tests unitaires ne font strictement rien. Il n'y a même pas d'assertion ! 

Il arrive en effet très fréquemment que les tests unitaires ne servent à rien. Oui, même dans la vraie vie, mais sur de gros projets. C'est encore plus vrai lorsqu'on commence à « surmocker » tout et n'importe quoi : un mock par-ci, un mock par-là... Il m'arrive de voir des tests unitaires où les assertions portent sur des mocks ; autant ne pas écrire de test unitaire.


<h2>Quel indicateur de qualité alors pour les tests unitaires?</h2>
 
Vous l'avez compris, il est difficile d'obtenir des indicateurs fiables de qualité pour des tests unitaires. Et encore, on ne cherche que des indicateurs...

C'est ici qu'intervient le Mutation Testing. Dès 1970 (oui, c'est vieux), s'est posée la question de savoir comment résoudre cette question de la qualité de tests. 

L'idée du Mutation Testing consiste à introduire des bugs dans le code source, puis à vérifier si les tests unitaires ont bien détecté ces bugs. Autrement dit, nous introduisons des mutations dans le code source (on parle de « mutants »), les tests unitaires sont sensés les détecter (on dit alors que le mutant en question est « tué »).

Si tous les bugs ont bien été détectés, c'est sans doute que les tests unitaires sont fiables. Si aucun bug n'est détecté, les tests unitaires ne servent à rien. Un indicateur de la qualité d'un test unitaire est donc que tous les mutants ont été tués.

Les avantages du Mutation Testing sont nombreux : 
c'est efficace
c'est très simple et ne recquiert pas de développement spécifique en plus des tests unitaires
c'est assez précis. 

Par contre,  le Mutation Testing a un certain nombre d'inconvénients :
C'est très très long (le volume de mutations possibles est exponentielle)
Il arrive qu'il y ait des faux positifs

Maintenant que les bases sont posées, parlons outils. Il n'existait en PHP qu'un seul outil pour le Mutation Testing : Mutegenis (https://github.com/padraic/mutagenesis). Malheureusement, cet outil, pourtant très intéressant, a deux inconvénients majeurs :
il est sorti trop tôt, à une époque où tester son code restait encore une pratique anecdotique en PHP
il nécessite d'installer une extension PHP assez lourde : RunKit

Partant de ce constat, j'ai réfléchi à une solution pour proposer un outil plus moderne et moins lourd. J'ai donc démarré le développement de MutaTesting (https://github.com/Halleck45/MutaTesting/) la semaine dernière.

<h2>MutaTesting, un nouvel outil pour la qualité PHP</h2>

MutaTesting, c'est quoi ? C'est un outil PHP pour créer des mutants à partir votre code source et pour lancer vos tests unitaires pour voir s'il est possible de tuer ces mutants.

Mon idée première a été de faire un outil très simple : pas besoin d'extension PHP, pas besoin de configuration compliquée ; il suffit, en ligne de commande, d'indiquer trois choses :
le framework de test utilisé
le chemin du binaire à exécuter pour lancer les tests
le dossier des tests unitaires
Par exemple, pour une suite de tests PHPUnit :

{% highlight %}
./bin/mutatesting phpunit phpunit.phar myTestFolder

{% endhighlight %}

ou pour atoum :

{% highlight %}
./bin/mutatesting atoum mageekguy.atoum.phar myTestFolder
{% endhighlight %}

C'est tout. A partir de là, MutaTesting va procéder à un certain nombre de processus :
1. les tests vont être lancés une première fois
2. chaque suite de test va être isolée, puis relancée pour déterminer quelles sources PHP elle permet de tester
3. le code source est converti en tokens, puis chaque token transformable est transformé en mutant
4. chaque suite de test va être relancée sur chaque mutation de code

Bien entendu, votre code source n'est jamais modifié. En réalité, l'outil joue avec un StreamWrapper spécifique pour le flux de fichier standard (file://) pour substituer la mutation à votre code originel.

Voici quelques exemples de bugs qui peuvent être introduits :
remplacer un test d'égalité (==) par un test de non-égalite (!=)
remplacer « true » par « false »
supprimer un bloc « else »
...

Voici, par exemple, le résultat de la mutation pour les tests de MutaTesting même :
















L'analyse du code source a donc permis de créer 46 mutants, donc 26 ont survécu. Le score des tests est donc de 43 %.

Les tests unitaires ont donc des anomalies. Relançons le même outil pour obtenir un compte rendu au format HTML, plus complet (commande –format=html). Voici un aperçu de ce qui est obtenu :


Cette fois-ci on a plus de détails : les mutants sont détaillés et regroupés par fichier de source. L'analyse de ce rapport va donc me permettre de me focaliser sur les tests unitaires qui concernent les sources sur lesquelles le plus de mutations a survécu.

<h2>Conclusion</h2>

Le Mutation Testing est donc finalement assez simple : on introduit des bugs dans un code source, puis on vérifie qu'ils sont bien détectés par les tests unitaires.

Ce qui est surtout intéressant c'est que cette pratique ne nécessite aucun développement en plus, mais simplement l'utilisation d'un outil.

Concernant MutaTesting même, que j'ai développé et qui est disponible sur Github, je pense que c'est un outil que j'espère simple à utiliser et à étendre. Bien que fonctionnel, il peut largement être amélioré.

N'hésitez pas à me faire des retours, tant sur cette pratique de test, que sur l'outil MutaTesting même si l'envie vous prend de l'essayer, voire d'y contribuer.
